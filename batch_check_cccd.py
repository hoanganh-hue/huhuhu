#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script ƒë·ªÉ batch check 5000 CCCD Qu·∫£ng Ninh n·ªØ (1965-1975) qua h·ªá th·ªëng check CCCD
ƒê·ªçc d·ªØ li·ªáu t·ª´ file Excel, g·ª≠i request batch, v√† xu·∫•t k·∫øt qu·∫£ t·ªïng h·ª£p
"""

import pandas as pd
import requests
import json
import time
import os
from datetime import datetime
from typing import List, Dict, Any
import sys
from src.utils.output_manager import get_output_manager, save_to_output, save_report, save_data


class BatchCCCDChecker:
    """Class ƒë·ªÉ batch check CCCD qua API."""

    def __init__(self, api_base_url: str = "http://localhost:8000"):
        self.api_base_url = api_base_url.rstrip('/')
        self.check_endpoint = f"{self.api_base_url}/api/v1/check"
        self.session = requests.Session()
        self.results = []
        self.stats = {
            'total_processed': 0,
            'successful_checks': 0,
            'failed_checks': 0,
            'found_matches': 0,
            'not_found': 0,
            'errors': 0,
            'total_time': 0
        }

    def load_cccd_from_excel(self, excel_file: str) -> List[str]:
        """ƒê·ªçc danh s√°ch CCCD t·ª´ file Excel."""
        print(f"üìñ ƒêang ƒë·ªçc file Excel: {excel_file}")

        try:
            # ƒê·ªçc sheet ch√≠nh ch·ª©a d·ªØ li·ªáu CCCD
            df = pd.read_excel(excel_file, sheet_name='CCCD_Data')

            # L·∫•y c·ªôt CCCD
            if 'CCCD' not in df.columns:
                print("‚ùå Kh√¥ng t√¨m th·∫•y c·ªôt 'CCCD' trong file Excel")
                return []

            # Convert CCCD to string properly
            cccd_list = []
            for cccd in df['CCCD'].dropna():
                cccd_str = str(int(cccd))  # Convert to int first, then to string
                # Add leading zero if needed to make 12 digits
                if len(cccd_str) == 11:
                    cccd_str = '0' + cccd_str
                cccd_list.append(cccd_str)

            # Validate format CCCD (12 digits)
            valid_cccd = [cccd for cccd in cccd_list if len(cccd) == 12 and cccd.isdigit()]

            print(f"‚úÖ ƒê√£ ƒë·ªçc {len(valid_cccd)} CCCD h·ª£p l·ªá t·ª´ {len(cccd_list)} b·∫£n ghi")
            return valid_cccd

        except Exception as e:
            print(f"‚ùå L·ªói khi ƒë·ªçc file Excel: {e}")
            return []

    def check_single_cccd(self, cccd: str) -> Dict[str, Any]:
        """Check m·ªôt CCCD qua API."""
        try:
            payload = {
                "cccd": cccd,
                "async_mode": False
            }

            headers = {
                "Content-Type": "application/json",
                "User-Agent": "Batch-CCCD-Checker/1.0"
            }

            start_time = time.time()
            response = self.session.post(
                self.check_endpoint,
                json=payload,
                headers=headers,
                timeout=30
            )
            response_time = time.time() - start_time

            if response.status_code == 200:
                result = response.json()
                return {
                    'cccd': cccd,
                    'status': 'success',
                    'response_time': response_time,
                    'api_status': result.get('status'),
                    'data': result.get('result'),
                    'error': None
                }
            else:
                return {
                    'cccd': cccd,
                    'status': 'error',
                    'response_time': response_time,
                    'api_status': None,
                    'data': None,
                    'error': f"HTTP {response.status_code}: {response.text}"
                }

        except Exception as e:
            return {
                'cccd': cccd,
                'status': 'error',
                'response_time': time.time() - time.time(),  # Will be 0
                'api_status': None,
                'data': None,
                'error': str(e)
            }

    def batch_check_cccd(self, cccd_list: List[str], batch_size: int = 10, delay: float = 2.0) -> List[Dict]:
        """Batch check danh s√°ch CCCD."""
        print(f"üöÄ B·∫Øt ƒë·∫ßu batch check {len(cccd_list)} CCCD")
        print(f"   - Batch size: {batch_size}")
        print(f"   - Delay gi·ªØa batches: {delay}s")
        print("-" * 60)

        start_time = time.time()
        results = []

        for i in range(0, len(cccd_list), batch_size):
            batch = cccd_list[i:i + batch_size]
            batch_num = (i // batch_size) + 1
            total_batches = (len(cccd_list) + batch_size - 1) // batch_size

            print(f"üì¶ Batch {batch_num}/{total_batches} - X·ª≠ l√Ω {len(batch)} CCCD")

            batch_start = time.time()
            batch_results = []

            for j, cccd in enumerate(batch):
                print(f"   {j+1:2d}. Checking CCCD: {cccd}", end=" ... ")

                result = self.check_single_cccd(cccd)
                batch_results.append(result)

                # Update stats
                self.stats['total_processed'] += 1
                if result['status'] == 'success':
                    self.stats['successful_checks'] += 1
                    if result.get('api_status') == 'completed':
                        api_result = result.get('data', {})
                        if api_result.get('status') == 'found':
                            self.stats['found_matches'] += 1
                        elif api_result.get('status') == 'not_found':
                            self.stats['not_found'] += 1
                else:
                    self.stats['failed_checks'] += 1
                    self.stats['errors'] += 1

                print(f"{'‚úÖ' if result['status'] == 'success' else '‚ùå'} "
                      f"({result['response_time']:.1f}s)")

            batch_time = time.time() - batch_start
            print(".1f")
            results.extend(batch_results)

            # Delay gi·ªØa batches (tr·ª´ batch cu·ªëi)
            if i + batch_size < len(cccd_list):
                print(f"‚è≥ ƒê·ª£i {delay}s tr∆∞·ªõc batch ti·∫øp theo...")
                time.sleep(delay)

        total_time = time.time() - start_time
        self.stats['total_time'] = total_time

        print("\n" + "="*60)
        print("üéâ HO√ÄN TH√ÄNH BATCH CHECK!")
        print("="*60)
        print(f"‚è±Ô∏è  T·ªïng th·ªùi gian: {total_time:.2f}s")
        print(f"üìä T·ªïng CCCD x·ª≠ l√Ω: {self.stats['total_processed']}")
        print(f"‚úÖ Th√†nh c√¥ng: {self.stats['successful_checks']}")
        print(f"‚ùå Th·∫•t b·∫°i: {self.stats['failed_checks']}")
        print(f"üîç T√¨m th·∫•y: {self.stats['found_matches']}")
        print(f"‚ùì Kh√¥ng t√¨m th·∫•y: {self.stats['not_found']}")
        print(".1f")
        print(".1f")
        return results

    def create_comprehensive_report(self, results: List[Dict], output_file: str = None) -> str:
        """T·∫°o b√°o c√°o t·ªïng h·ª£p chi ti·∫øt."""
        if output_file is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"batch_check_results_{timestamp}.xlsx"

        print(f"\nüìä T·∫°o b√°o c√°o t·ªïng h·ª£p: {output_file}")

        # Chu·∫©n b·ªã d·ªØ li·ªáu cho Excel
        excel_data = []

        for result in results:
            row = {
                'STT': len(excel_data) + 1,
                'CCCD': result['cccd'],
                'Tr·∫°ng th√°i check': 'Th√†nh c√¥ng' if result['status'] == 'success' else 'Th·∫•t b·∫°i',
                'Th·ªùi gian response (s)': round(result['response_time'], 2),
                'API Status': result.get('api_status', 'N/A'),
                'K·∫øt qu·∫£ t√¨m ki·∫øm': 'N/A',
                'S·ªë matches': 0,
                'T√™n': '',
                'M√£ s·ªë thu·∫ø': '',
                'ƒê·ªãa ch·ªâ': '',
                'Ch·ª©c v·ª•': '',
                'URL': '',
                'L·ªói': result.get('error', '')
            }

            # N·∫øu th√†nh c√¥ng, extract th√¥ng tin chi ti·∫øt
            if result['status'] == 'success' and result.get('data'):
                data = result['data']
                row['K·∫øt qu·∫£ t√¨m ki·∫øm'] = data.get('status', 'unknown')
                matches = data.get('matches', [])
                row['S·ªë matches'] = len(matches)

                if matches:
                    match = matches[0]  # L·∫•y match ƒë·∫ßu ti√™n
                    row['T√™n'] = match.get('name', '')
                    row['M√£ s·ªë thu·∫ø'] = match.get('tax_code', '')
                    row['ƒê·ªãa ch·ªâ'] = match.get('address', '')
                    row['Ch·ª©c v·ª•'] = match.get('role', '')
                    row['URL'] = match.get('url', '')

            excel_data.append(row)

        # T·∫°o DataFrame
        df = pd.DataFrame(excel_data)

        # T·∫°o file Excel v·ªõi multiple sheets
        with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
            # Sheet ch√≠nh
            df.to_excel(writer, sheet_name='Ket_Qua_Check', index=False)

            # Sheet th·ªëng k√™
            stats_data = self._create_stats_sheet()
            stats_df = pd.DataFrame(stats_data)
            stats_df.to_excel(writer, sheet_name='Thong_Ke', index=False)

            # Sheet t√≥m t·∫Øt
            summary_data = self._create_summary_sheet(results)
            summary_df = pd.DataFrame(summary_data)
            summary_df.to_excel(writer, sheet_name='Tom_Tat', index=False)

        print(f"‚úÖ B√°o c√°o ƒë√£ ƒë∆∞·ª£c t·∫°o: {output_file}")
        return output_file

    def _create_stats_sheet(self) -> List[Dict]:
        """T·∫°o sheet th·ªëng k√™."""
        stats = self.stats
        return [
            {'Ch·ªâ s·ªë': 'T·ªïng CCCD x·ª≠ l√Ω', 'Gi√° tr·ªã': stats['total_processed']},
            {'Ch·ªâ s·ªë': 'Th√†nh c√¥ng', 'Gi√° tr·ªã': stats['successful_checks']},
            {'Ch·ªâ s·ªë': 'Th·∫•t b·∫°i', 'Gi√° tr·ªã': stats['failed_checks']},
            {'Ch·ªâ s·ªë': 'T√¨m th·∫•y th√¥ng tin', 'Gi√° tr·ªã': stats['found_matches']},
            {'Ch·ªâ s·ªë': 'Kh√¥ng t√¨m th·∫•y', 'Gi√° tr·ªã': stats['not_found']},
            {'Ch·ªâ s·ªë': 'T·ª∑ l·ªá th√†nh c√¥ng', 'Gi√° tr·ªã': f"{(stats['successful_checks'] / max(stats['total_processed'], 1) * 100):.1f}%"},
            {'Ch·ªâ s·ªë': 'T·ª∑ l·ªá t√¨m th·∫•y', 'Gi√° tr·ªã': f"{(stats['found_matches'] / max(stats['total_processed'], 1) * 100):.1f}%"},
            {'Ch·ªâ s·ªë': 'T·ªïng th·ªùi gian (gi√¢y)', 'Gi√° tr·ªã': round(stats['total_time'], 2)},
            {'Ch·ªâ s·ªë': 'Th·ªùi gian trung b√¨nh/CCCD (gi√¢y)', 'Gi√° tr·ªã': round(stats['total_time'] / max(stats['total_processed'], 1), 2)},
        ]

    def _create_summary_sheet(self, results: List[Dict]) -> List[Dict]:
        """T·∫°o sheet t√≥m t·∫Øt."""
        # Ph√¢n t√≠ch theo tr·∫°ng th√°i
        status_counts = {}
        for result in results:
            status = result.get('api_status', 'unknown')
            status_counts[status] = status_counts.get(status, 0) + 1

        summary = [
            {'Th√¥ng tin': 'Th·ªùi gian th·ª±c hi·ªán', 'Gi√° tr·ªã': datetime.now().strftime('%Y-%m-%d %H:%M:%S')},
            {'Th√¥ng tin': 'File ngu·ªìn', 'Gi√° tr·ªã': 'quang_ninh_female_1965_1975.xlsx'},
            {'Th√¥ng tin': 'API Endpoint', 'Gi√° tr·ªã': self.check_endpoint},
            {'Th√¥ng tin': 'T·ªïng s·ªë CCCD', 'Gi√° tr·ªã': len(results)},
        ]

        for status, count in status_counts.items():
            summary.append({
                'Th√¥ng tin': f'API Status: {status}',
                'Gi√° tr·ªã': f'{count} ({count/len(results)*100:.1f}%)'
            })

        return summary

def main():
    """Main function."""
    print("üöÄ BATCH CHECK CCCD - Qu·∫£ng Ninh N·ªØ (1965-1975)")
    print("=" * 60)

    # Kh·ªüi t·∫°o checker
    checker = BatchCCCDChecker()

    # File Excel ch·ª©a 5000 CCCD
    excel_file = "quang_ninh_female_1965_1975.xlsx"

    # Ki·ªÉm tra file t·ªìn t·∫°i
    if not os.path.exists(excel_file):
        print(f"‚ùå File Excel kh√¥ng t·ªìn t·∫°i: {excel_file}")
        sys.exit(1)

    # ƒê·ªçc danh s√°ch CCCD
    cccd_list = checker.load_cccd_from_excel(excel_file)

    if not cccd_list:
        print("‚ùå Kh√¥ng c√≥ CCCD n√†o ƒë·ªÉ check")
        sys.exit(1)

    # Batch check (gi·ªõi h·∫°n 100 CCCD ƒë·∫ßu ti√™n ƒë·ªÉ test)
    test_limit = min(100, len(cccd_list))  # Test v·ªõi 100 CCCD ƒë·∫ßu ti√™n
    print(f"üß™ Test v·ªõi {test_limit} CCCD ƒë·∫ßu ti√™n...")

    results = checker.batch_check_cccd(
        cccd_list[:test_limit],
        batch_size=5,  # 5 CCCD per batch
        delay=3.0      # 3 gi√¢y delay gi·ªØa batches
    )

    # T·∫°o b√°o c√°o
    output_file = checker.create_comprehensive_report(results)

    print("\n" + "="*60)
    print("üéâ HO√ÄN TH√ÄNH!")
    print("="*60)
    print(f"üìÅ File k·∫øt qu·∫£: {output_file}")
    print(f"üìä ƒê√£ check: {len(results)}/{len(cccd_list)} CCCD")
    print(f"‚úÖ Th√†nh c√¥ng: {checker.stats['successful_checks']}")
    print(f"üîç T√¨m th·∫•y: {checker.stats['found_matches']}")
    print(".1f")
    if len(cccd_list) > test_limit:
        print(f"\nüí° ƒê·ªÉ check to√†n b·ªô {len(cccd_list)} CCCD, ch·∫°y v·ªõi test_limit = {len(cccd_list)}")

if __name__ == "__main__":
    main()