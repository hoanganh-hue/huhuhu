#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Project Structure Validation Script
Ki·ªÉm tra v√† validate c·∫•u tr√∫c d·ª± √°n ƒë·ªÉ ƒë·∫£m b·∫£o logic flow kh√¥ng c√≥ xung ƒë·ªôt
"""

import os
import sys
import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any

class ProjectValidator:
    """Class ƒë·ªÉ validate c·∫•u tr√∫c d·ª± √°n"""
    
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root)
        self.validation_results = {
            'timestamp': datetime.now().isoformat(),
            'total_files': 0,
            'total_directories': 0,
            'issues': [],
            'warnings': [],
            'recommendations': [],
            'file_conflicts': [],
            'dependency_conflicts': [],
            'structure_score': 0
        }
    
    def validate_structure(self) -> Dict[str, Any]:
        """Validate to√†n b·ªô c·∫•u tr√∫c d·ª± √°n"""
        print("üîç B·∫Øt ƒë·∫ßu validation c·∫•u tr√∫c d·ª± √°n...")
        
        # ƒê·∫øm files v√† directories
        self._count_files_and_directories()
        
        # Ki·ªÉm tra conflicts
        self._check_file_conflicts()
        self._check_dependency_conflicts()
        self._check_naming_conventions()
        self._check_directory_structure()
        
        # T√≠nh ƒëi·ªÉm structure
        self._calculate_structure_score()
        
        return self.validation_results
    
    def _count_files_and_directories(self):
        """ƒê·∫øm s·ªë l∆∞·ª£ng files v√† directories"""
        file_count = 0
        dir_count = 0
        
        for root, dirs, files in os.walk(self.project_root):
            # B·ªè qua .venv v√† c√°c th∆∞ m·ª•c ·∫©n kh√°c
            if '.venv' in root or '__pycache__' in root:
                continue
                
            dir_count += len(dirs)
            file_count += len(files)
        
        self.validation_results['total_files'] = file_count
        self.validation_results['total_directories'] = dir_count
    
    def _check_file_conflicts(self):
        """Ki·ªÉm tra xung ƒë·ªôt files"""
        print("üìã Ki·ªÉm tra xung ƒë·ªôt files...")
        
        # Ki·ªÉm tra duplicate names
        file_names = {}
        for root, dirs, files in os.walk(self.project_root):
            if '.venv' in root or '__pycache__' in root:
                continue
                
            for file in files:
                if file in file_names:
                    self.validation_results['file_conflicts'].append({
                        'type': 'duplicate_name',
                        'file': file,
                        'locations': [file_names[file], os.path.join(root, file)]
                    })
                else:
                    file_names[file] = os.path.join(root, file)
        
        # Ki·ªÉm tra main entry points
        main_files = ['main.py', 'app.py', 'run.py', 'start.py']
        found_mains = []
        for main_file in main_files:
            if (self.project_root / main_file).exists():
                found_mains.append(main_file)
        
        if len(found_mains) > 1:
            self.validation_results['warnings'].append({
                'type': 'multiple_main_files',
                'files': found_mains,
                'message': 'Nhi·ªÅu file main entry point c√≥ th·ªÉ g√¢y nh·∫ßm l·∫´n'
            })
    
    def _check_dependency_conflicts(self):
        """Ki·ªÉm tra xung ƒë·ªôt dependencies"""
        print("üì¶ Ki·ªÉm tra xung ƒë·ªôt dependencies...")
        
        requirements_files = list(self.project_root.glob("requirements*.txt"))
        if len(requirements_files) > 1:
            self.validation_results['dependency_conflicts'].append({
                'type': 'multiple_requirements',
                'files': [str(f) for f in requirements_files],
                'message': 'Nhi·ªÅu file requirements c√≥ th·ªÉ g√¢y xung ƒë·ªôt'
            })
        
        # Ki·ªÉm tra setup.py conflicts
        setup_files = list(self.project_root.glob("setup*.py"))
        if len(setup_files) > 1:
            self.validation_results['dependency_conflicts'].append({
                'type': 'multiple_setup',
                'files': [str(f) for f in setup_files],
                'message': 'Nhi·ªÅu file setup c√≥ th·ªÉ g√¢y xung ƒë·ªôt'
            })
    
    def _check_naming_conventions(self):
        """Ki·ªÉm tra naming conventions"""
        print("üìù Ki·ªÉm tra naming conventions...")
        
        # Ki·ªÉm tra Python files
        python_files = list(self.project_root.rglob("*.py"))
        for py_file in python_files:
            if '.venv' in str(py_file) or '__pycache__' in str(py_file):
                continue
                
            # Ki·ªÉm tra naming convention
            if py_file.name != py_file.name.lower():
                self.validation_results['warnings'].append({
                    'type': 'naming_convention',
                    'file': str(py_file),
                    'message': 'Python file names should be lowercase'
                })
    
    def _check_directory_structure(self):
        """Ki·ªÉm tra c·∫•u tr√∫c th∆∞ m·ª•c"""
        print("üìÅ Ki·ªÉm tra c·∫•u tr√∫c th∆∞ m·ª•c...")
        
        # Ki·ªÉm tra c√°c th∆∞ m·ª•c quan tr·ªçng
        important_dirs = ['config', 'modules', 'utils', 'tests', 'logs', 'output']
        missing_dirs = []
        
        for dir_name in important_dirs:
            if not (self.project_root / dir_name).exists():
                missing_dirs.append(dir_name)
        
        if missing_dirs:
            self.validation_results['recommendations'].append({
                'type': 'missing_directories',
                'directories': missing_dirs,
                'message': 'N√™n t·∫°o c√°c th∆∞ m·ª•c n√†y ƒë·ªÉ t·ªï ch·ª©c t·ªët h∆°n'
            })
        
        # Ki·ªÉm tra archive directory
        if (self.project_root / 'archive').exists():
            self.validation_results['recommendations'].append({
                'type': 'archive_found',
                'message': 'Th∆∞ m·ª•c archive ƒë√£ ƒë∆∞·ª£c t·∫°o ƒë·ªÉ t·ªï ch·ª©c files'
            })
    
    def _calculate_structure_score(self):
        """T√≠nh ƒëi·ªÉm c·∫•u tr√∫c"""
        score = 100
        
        # Tr·ª´ ƒëi·ªÉm cho c√°c issues
        score -= len(self.validation_results['file_conflicts']) * 10
        score -= len(self.validation_results['dependency_conflicts']) * 15
        score -= len(self.validation_results['issues']) * 5
        score -= len(self.validation_results['warnings']) * 2
        
        # C·ªông ƒëi·ªÉm cho recommendations ƒë∆∞·ª£c th·ª±c hi·ªán
        if any(rec['type'] == 'archive_found' for rec in self.validation_results['recommendations']):
            score += 10
        
        self.validation_results['structure_score'] = max(0, min(100, score))
    
    def generate_report(self) -> str:
        """T·∫°o b√°o c√°o validation"""
        report = []
        report.append("=" * 80)
        report.append("üìä PROJECT STRUCTURE VALIDATION REPORT")
        report.append("=" * 80)
        report.append(f"üïê Timestamp: {self.validation_results['timestamp']}")
        report.append(f"üìÅ Total Files: {self.validation_results['total_files']}")
        report.append(f"üìÇ Total Directories: {self.validation_results['total_directories']}")
        report.append(f"‚≠ê Structure Score: {self.validation_results['structure_score']}/100")
        report.append("")
        
        # Issues
        if self.validation_results['issues']:
            report.append("‚ùå ISSUES:")
            for issue in self.validation_results['issues']:
                report.append(f"  - {issue}")
            report.append("")
        
        # File Conflicts
        if self.validation_results['file_conflicts']:
            report.append("‚ö†Ô∏è FILE CONFLICTS:")
            for conflict in self.validation_results['file_conflicts']:
                report.append(f"  - {conflict['type']}: {conflict['file']}")
                if 'locations' in conflict:
                    for loc in conflict['locations']:
                        report.append(f"    ‚Üí {loc}")
            report.append("")
        
        # Dependency Conflicts
        if self.validation_results['dependency_conflicts']:
            report.append("üì¶ DEPENDENCY CONFLICTS:")
            for conflict in self.validation_results['dependency_conflicts']:
                report.append(f"  - {conflict['type']}: {conflict['message']}")
                if 'files' in conflict:
                    for file in conflict['files']:
                        report.append(f"    ‚Üí {file}")
            report.append("")
        
        # Warnings
        if self.validation_results['warnings']:
            report.append("‚ö†Ô∏è WARNINGS:")
            for warning in self.validation_results['warnings']:
                report.append(f"  - {warning['message']}")
                if 'file' in warning:
                    report.append(f"    ‚Üí {warning['file']}")
            report.append("")
        
        # Recommendations
        if self.validation_results['recommendations']:
            report.append("üí° RECOMMENDATIONS:")
            for rec in self.validation_results['recommendations']:
                report.append(f"  - {rec['message']}")
            report.append("")
        
        # Summary
        report.append("üìã SUMMARY:")
        if self.validation_results['structure_score'] >= 90:
            report.append("  ‚úÖ Excellent project structure!")
        elif self.validation_results['structure_score'] >= 70:
            report.append("  ‚úÖ Good project structure with minor issues")
        elif self.validation_results['structure_score'] >= 50:
            report.append("  ‚ö†Ô∏è Fair project structure, needs improvement")
        else:
            report.append("  ‚ùå Poor project structure, requires major cleanup")
        
        report.append("=" * 80)
        
        return "\n".join(report)

def main():
    """Main function"""
    print("üöÄ Starting Project Structure Validation...")
    
    validator = ProjectValidator()
    results = validator.validate_structure()
    
    # In b√°o c√°o
    report = validator.generate_report()
    print(report)
    
    # L∆∞u b√°o c√°o
    report_file = Path("validation_report.txt")
    with open(report_file, 'w', encoding='utf-8') as f:
        f.write(report)
    
    print(f"\nüìÑ B√°o c√°o ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o: {report_file}")
    
    # L∆∞u k·∫øt qu·∫£ JSON
    json_file = Path("validation_results.json")
    with open(json_file, 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=2, ensure_ascii=False)
    
    print(f"üìä K·∫øt qu·∫£ chi ti·∫øt ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o: {json_file}")
    
    return results['structure_score'] >= 70

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)